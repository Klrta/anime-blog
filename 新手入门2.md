# 新手入门指南 (进阶篇)

恭喜你完成了第一阶段的博客搭建！现在的你已经拥有了一个功能完备、美观的个人博客。
但这只是开始。在进阶篇中，我们将探索更多有趣的功能，把你的博客打造成真正的“全能战舰”。

## 学习路线图 (Roadmap)

### 1. 交互与功能增强
- [ ] **评论系统**: 让访客能留言（推荐 Giscus，基于 GitHub Discussions，免费且无广告，非常适合程序员博客）。
- [ ] **站内搜索**: 当文章变多时，一个搜索框是必不可少的（可以使用简单的本地搜索或者 Algolia）。
- [ ] **分页功能**: 首页文章太多加载慢？学学怎么做分页 (Pagination)。
- [ ] **RSS 订阅**: 让喜欢你博客的人能通过 RSS 阅读器订阅更新。

### 2. 视觉与体验优化
- [ ] **图片优化**: 学习 Next.js 的 `<Image>` 组件，自动压缩图片，防止页面加载卡顿。
- [ ] **页面切换动画**: 使用 `framer-motion` 给页面切换加上丝滑的过渡效果。
- [ ] **自定义字体**: 引入更好看的个性化字体。

### 3. 内容增强 (MDX)
- [ ] **MDX 升级**: 现在的 Markdown 只能写文字和图。升级到 MDX 后，你可以在文章里直接插入 React 组件（比如一个可交互的图表、一个音乐播放器、或者一个 B 站视频卡片）。

### 4. 运维与 SEO
- [ ] **SEO 优化**: 让搜索引擎更容易搜到你的博客（Metadata, Sitemap）。
- [ ] **数据统计**: 看看有多少人访问了你的博客（Vercel Analytics）。

---

## 建议的下一步
既然你已经有了标签功能（我看构建日志里有 `/tags`），不如我们先从 **评论系统** 或者 **站内搜索** 开始？这两个功能对博客的互动性提升最大。

或者，如果你觉得现在的文章排版还不够丰富，我们可以尝试 **MDX**。

**你想先学哪个？告诉我，我们就在这个文档里开始新的教程！**



下一步:学习**评论系统**: 让访客能留言.推荐 Giscus，基于 GitHub Discussions.

---

# 第一章：给博客添加评论系统 (Giscus)

Giscus 是一个非常棒的评论系统，它利用 GitHub 的 "Discussions" (讨论区) 功能来存储评论。这意味着你的数据完全掌握在自己手里，而且免费、无广告。

## 第一步：GitHub 仓库配置 (你需要亲自操作)

因为涉及到你的 GitHub 权限，这一步需要你去 GitHub 网站上操作：

1.  **开启 Discussions 功能**：
    *   打开你的 GitHub 仓库页面 (`anime-blog`)。
    *   点击上方的 **Settings** (设置)。
    *   在 General (常规) 页面向下滚动，找到 **Features** (功能) 区域。
    *   勾选 **Discussions**。

2.  **安装 Giscus App**：
    *   访问 [Giscus App](https://github.com/apps/giscus) 页面。
    *   点击 **Install**，选择你的 `anime-blog` 仓库进行安装。

3.  **获取配置参数**：
    *   访问 [Giscus 官网](https://giscus.app/zh-CN)。
    *   在页面上输入你的仓库名 (例如 `Klrta/anime-blog`)。
    *   在“页面 ↔️ discussion 映射关系”中，推荐选择 **"Discussion title contains page title"**。
    *   在“Discussion 分类”中，推荐选择 **"Announcements"** (或者你自己新建一个叫 Comments 的分类)。
    *   **关键步骤**：滚动到页面底部，你会看到一段生成的代码。我们需要其中的 `data-repo-id` 和 `data-category-id` 这两个值。

## 第二步：创建评论组件

拿到 ID 后，我们就可以写代码了。

1.  **安装依赖**：
    我们需要一个库来方便地引入 Giscus。
    ```bash
    npm install @giscus/react
    ```

2.  **新建组件文件**：
    创建 `src/components/Comments.tsx`，代码如下：
    *(请把下面的 `repoId` 和 `categoryId` 换成你刚才获取到的)*

    ```tsx
    'use client';
    
    import Giscus from '@giscus/react';
    import { useTheme } from 'next-themes';
    
    export default function Comments() {
      const { theme } = useTheme();
    
      return (
        <div className="mt-10 pt-10 border-t border-gray-200 dark:border-gray-800">
          <Giscus
            id="comments"
            repo="Klrta/anime-blog" // 你的仓库名
            repoId="YOUR_REPO_ID"   // 替换这里！！！
            category="Announcements"
            categoryId="YOUR_CATEGORY_ID" // 替换这里！！！
            mapping="title"
            reactionsEnabled="1"
            emitMetadata="0"
            inputPosition="top"
            theme={theme === 'dark' ? 'transparent_dark' : 'light'}
            lang="zh-CN"
            loading="lazy"
          />
        </div>
      );
    }
    ```

## 第三步：在文章页引入

最后，把这个组件放到文章详情页的最下面。
打开 `src/app/posts/[id]/page.tsx`：

```tsx
// ... 其他引入
import Comments from '@/components/Comments'; // 引入组件

export default async function Post({ params }: { params: Promise<{ id: string }> }) {
  // ... 前面的代码

  return (
    <div className="...">
      <article className="...">
        {/* ... 文章头部和正文 ... */}
        
        {/* 在 article 结束标签之前，或者之后，放入评论组件 */}
        <Comments />
      </article>
    </div>
  );
}
```

---

# 第二章：统一文章详情页的风格

你可能注意到了，当你点进一篇文章时，顶部的导航栏不见了，而且背景也不像首页那样是滚动的。这是因为文章详情页 (`src/app/posts/[id]/page.tsx`) 还没有更新样式。

让我们把它也变得漂亮且统一。

## 1. 修改文章页代码

打开 `src/app/posts/[id]/page.tsx`，用下面的代码完全替换它。
这段代码做了以下改进：
1.  **添加了导航栏**：和首页、归档页保持一致。
2.  **背景透明化**：去掉了 `bg-anime-cream`，让全局滚动背景透出来。
3.  **暗黑模式适配**：文字颜色和背景色都适配了深色模式。

```tsx
import Link from 'next/link';
import { getPostData, getAllPosts } from '@/lib/posts';
import Comments from '@/components/Comments';
import ThemeToggle from '@/components/ThemeToggle';

// 生成静态路径
export async function generateStaticParams() {
  const posts = getAllPosts();
  return posts.map((post) => ({
    id: post.id,
  }));
}

// 页面组件
export default async function Post({ params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  const postData = await getPostData(id);

  return (
    <div className="min-h-screen text-gray-800 dark:text-gray-100 font-sans relative z-10">
      {/* Header (与首页保持一致) */}
      <header className="fixed top-0 w-full z-50 backdrop-blur-md bg-white/30 dark:bg-black/30 border-b border-white/20 dark:border-white/10">
        <div className="max-w-6xl mx-auto px-6 h-16 flex items-center justify-between">
          <div className="text-xl font-bold text-anime-blue tracking-wider">
            AnimeBlog
          </div>
          <nav className="flex gap-6 text-sm font-medium text-gray-600 dark:text-gray-300 items-center">
            <Link href="/" className="hover:text-anime-pink transition-colors">首页</Link>
            <Link href="/archive" className="hover:text-anime-pink transition-colors">归档</Link>
            <Link href="/about" className="hover:text-anime-pink transition-colors">关于</Link>
            <ThemeToggle />
          </nav>
        </div>
      </header>

      {/* 文章内容 */}
      <main className="pt-24 pb-16 px-6">
        <article className="max-w-3xl mx-auto bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm rounded-3xl shadow-xl shadow-anime-pink/10 dark:shadow-none overflow-hidden border border-white/50 dark:border-gray-700">
          {/* 文章头部 */}
          <header className="bg-gradient-to-r from-anime-pink/20 to-anime-blue/20 p-10 text-center">
            <h1 className="text-3xl md:text-4xl font-bold text-gray-800 dark:text-gray-100 mb-4">
              {postData.title}
            </h1>
            <time className="text-anime-blue dark:text-anime-pink font-medium bg-white/60 dark:bg-black/20 px-4 py-1 rounded-full text-sm">
              {postData.date}
            </time>
          </header>

          {/* 文章正文 */}
          <div 
            className="p-10 prose prose-pink dark:prose-invert max-w-none prose-headings:text-anime-blue dark:prose-headings:text-anime-pink prose-a:text-anime-pink"
            dangerouslySetInnerHTML={{ __html: postData.contentHtml || '' }} 
          />
          
          {/* 评论区 */}
          <div className="px-10 pb-10">
            <Comments />
          </div>
        </article>
      </main>
    </div>
  );
}
```

---

# 第三章：添加简单的搜索功能

文章变多后，我们需要一个搜索框。为了简单起见，我们先在 **归档页面** 添加一个搜索框，用来过滤文章列表。

## 1. 创建搜索组件

因为搜索需要用户输入（交互），所以必须是一个 `Client Component`（客户端组件）。

新建文件 `src/components/SearchPosts.tsx`：

```tsx
'use client';

import { useState } from 'react';
import Link from 'next/link';

// 定义文章数据的类型
interface Post {
  id: string;
  title: string;
  date: string;
  description?: string;
}

export default function SearchPosts({ posts }: { posts: Post[] }) {
  const [query, setQuery] = useState('');

  // 根据输入过滤文章
  const filteredPosts = posts.filter((post) => {
    const searchContent = (post.title + post.description).toLowerCase();
    return searchContent.includes(query.toLowerCase());
  });

  return (
    <div>
      {/* 搜索框 */}
      <div className="mb-10 relative max-w-md mx-auto">
        <input
          type="text"
          placeholder="搜索文章..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          className="w-full px-6 py-3 rounded-full border-2 border-anime-pink/30 focus:border-anime-pink focus:outline-none bg-white/50 dark:bg-gray-800/50 backdrop-blur-sm transition-all text-center placeholder-gray-400 dark:text-gray-100"
        />
        <span className="absolute right-4 top-3.5 text-anime-pink">🔍</span>
      </div>

      {/* 文章列表 (原本在 archive/page.tsx 里的那部分代码移到这里) */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
        {filteredPosts.map((post) => (
          <article
            key={post.id}
            className="group bg-white dark:bg-gray-800 rounded-2xl p-6 shadow-lg shadow-anime-pink/20 dark:shadow-none hover:shadow-anime-pink/40 hover:-translate-y-1 transition-all duration-300 border border-gray-100 dark:border-gray-700 flex flex-col"
          >
            <div className="mb-4">
              <span className="text-xs font-medium text-anime-blue bg-anime-blue/10 dark:bg-anime-blue/20 px-2 py-1 rounded-full">
                {post.date}
              </span>
            </div>
            <h2 className="text-xl font-bold mb-2 group-hover:text-anime-pink transition-colors text-gray-800 dark:text-gray-100">
              {post.title}
            </h2>
            <p className="text-gray-500 dark:text-gray-400 text-sm line-clamp-3 mb-4 flex-grow">
              {post.description}
            </p>
            <Link
              href={`/posts/${post.id}`}
              className="text-sm font-medium text-anime-pink hover:text-anime-blue transition-colors mt-auto"
            >
              阅读更多 →
            </Link>
          </article>
        ))}
      </div>
      
      {filteredPosts.length === 0 && (
        <div className="text-center text-gray-500 py-10">
          没有找到相关文章 (｡•́︿•̀｡)
        </div>
      )}
    </div>
  );
}
```

## 2. 修改归档页面

现在我们需要修改 `src/app/archive/page.tsx`，让它使用我们刚写的 `SearchPosts` 组件。

```tsx
import Link from 'next/link';
import { getAllPosts } from '@/lib/posts';
import ThemeToggle from '@/components/ThemeToggle';
import SearchPosts from '@/components/SearchPosts'; // 引入新组件

export default function Archive() {
  const posts = getAllPosts();

  return (
    <div className="min-h-screen text-gray-800 dark:text-gray-100 font-sans relative z-10">
      {/* Header (保持不变) */}
      <header className="fixed top-0 w-full z-50 backdrop-blur-md bg-white/30 dark:bg-black/30 border-b border-white/20 dark:border-white/10">
        <div className="max-w-6xl mx-auto px-6 h-16 flex items-center justify-between">
          <div className="text-xl font-bold text-anime-blue tracking-wider">
            AnimeBlog
          </div>
          <nav className="flex gap-6 text-sm font-medium text-gray-600 dark:text-gray-300 items-center">
            <Link href="/" className="hover:text-anime-pink transition-colors">首页</Link>
            <Link href="/archive" className="hover:text-anime-pink transition-colors">归档</Link>
            <Link href="/about" className="hover:text-anime-pink transition-colors">关于</Link>
            <ThemeToggle />
          </nav>
        </div>
      </header>

      {/* Main Content */}
      <main className="max-w-6xl mx-auto px-6 py-24">
        <div className="text-center mb-12">
          <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-100 mb-4">文章归档</h1>
          <p className="text-gray-500 dark:text-gray-400">这里记录了所有的思绪与足迹</p>
        </div>
        
        {/* 使用搜索组件来显示文章列表 */}
        <SearchPosts posts={posts} />
      </main>

      {/* Footer */}
      <footer className="py-8 text-center text-gray-400 text-sm">
        © {new Date().getFullYear()} AnimeBlog. Built with Next.js & Tailwind.
      </footer>
    </div>
  );
}
```

---
**现在的任务**：
1.  先完成 **第二章**，把文章详情页的样式统一了。
2.  然后尝试 **第三章**，给归档页加上搜索功能。
3.  做完告诉我，我们再继续！

---
**现在的任务**：
请先去完成 **第一步**，拿到 `repoId` 和 `categoryId`，然后告诉我，我来帮你写代码！

我完成了第二章和第三章,效果如图所示

![image-20251212155929020](C:\Users\donuq\AppData\Roaming\Typora\typora-user-images\image-20251212155929020.png)![image-20251212155951677](C:\Users\donuq\AppData\Roaming\Typora\typora-user-images\image-20251212155951677.png)

我想巩固下现在的知识

---

# 第四章：知识点巩固 (Review)

太棒了！你已经成功完成了进阶功能的开发。为了让你真正掌握这些技能，我们来回顾一下刚才用到的核心知识点。

## 1. 客户端组件 vs 服务端组件 ('use client')
你可能注意到了，我们在 `SearchPosts.tsx` 和 `Comments.tsx` 的第一行都写了 `'use client'`。
*   **服务端组件 (默认)**: Next.js 默认所有的组件都是在服务器上渲染好 HTML 再发给浏览器的。这样速度快，SEO 好。
*   **客户端组件**: 当我们需要**交互**（比如点击按钮、输入文字、使用 `useState`）时，必须告诉 Next.js：“这个组件需要在浏览器里运行 JavaScript”。
*   **判断标准**: 只要用到了 `useState`, `useEffect`, `onClick` 等功能，就必须加 `'use client'`。

## 2. React 状态管理 (useState)
在搜索功能中，我们用到了 `useState`：
```tsx
const [query, setQuery] = useState('');
```
*   **query**: 这是一个变量，存着用户当前输入的搜索词。
*   **setQuery**: 这是一个函数，用来更新 `query` 的值。
*   **原理**: 每当用户在输入框里打字，`onChange` 事件就会调用 `setQuery`，更新 `query`。一旦 `query` 变了，React 就会自动重新运行组件代码，计算出新的 `filteredPosts`，页面上的文章列表也就跟着变了。这就是 React 的“响应式”魔力！

## 3. 组件化思维 (Component)
我们没有把搜索代码直接写在 `archive/page.tsx` 里，而是单独做了一个 `SearchPosts.tsx`。
*   **好处**:
    1.  **代码清晰**: `archive/page.tsx` 只负责获取数据和布局，不负责复杂的搜索逻辑。
    2.  **复用性**: 如果以后你想在首页也加个搜索框，直接引入这个组件就行了，不用重写代码。

## 4. 样式统一与布局
我们手动把 `Header` 代码复制到了文章详情页。
*   **思考**: 其实这样复制粘贴有点麻烦，如果以后要改导航栏，得改三个地方（首页、归档、文章页）。
*   **进阶优化**: 在 Next.js 中，通常会把导航栏放在 `layout.tsx` 里，这样它就会自动出现在所有页面上，不需要每个页面都写一遍。这是我们未来可以优化的方向！

---

## 下一步挑战：分页功能 (Pagination)
既然你已经学会了搜索（过滤数据），那么**分页**（切分数据）就是最好的下一个挑战。
当你的文章写到 100 篇的时候，你肯定不希望一页全展示出来。

**准备好继续了吗？告诉我，我们开始下一章！**



分页功能怎么做,是什么思路

---

# 第五章：实现分页功能 (Pagination)

当文章越来越多时，我们不能把它们全部堆在一个页面上。分页功能的本质其实就是**“切蛋糕”**。

## 1. 分页的核心思路 (Logic)

假设你有 10 块蛋糕（10 篇文章），你想每次只给客人看 3 块（每页 3 篇）。

1.  **第一页 (Page 1)**: 你切出第 1~3 块 (`posts.slice(0, 3)`)。
2.  **第二页 (Page 2)**: 你切出第 4~6 块 (`posts.slice(3, 6)`)。
3.  **第三页 (Page 3)**: 你切出第 7~9 块 (`posts.slice(6, 9)`)。
4.  **第四页 (Page 4)**: 剩下第 10 块 (`posts.slice(9, 12)`)。

**公式**:

*   **开始切的位置** = `(当前页码 - 1) * 每页数量`
*   **结束切的位置** = `开始切的位置 + 每页数量`

## 2. 实战：升级 SearchPosts 组件

因为我们的归档页面已经用 `SearchPosts` 组件来显示文章列表了，所以我们直接在这个组件里加分页功能。这样还能顺便实现“搜索结果的分页”！

打开 `src/components/SearchPosts.tsx`，用下面的代码**完全替换**它：

```tsx
'use client';

import { useState } from 'react';
import Link from 'next/link';

interface Post {
  id: string;
  title: string;
  date: string;
  description?: string;
}

const POSTS_PER_PAGE = 6; // 每页显示 6 篇文章

export default function SearchPosts({ posts }: { posts: Post[] }) {
  const [query, setQuery] = useState('');
  const [currentPage, setCurrentPage] = useState(1); // 新增：当前页码状态

  // 1. 先进行搜索过滤
  const filteredPosts = posts.filter((post) => {
    const searchContent = (post.title + post.description).toLowerCase();
    return searchContent.includes(query.toLowerCase());
  });

  // 2. 计算分页数据
  const totalPages = Math.ceil(filteredPosts.length / POSTS_PER_PAGE);
  const startIndex = (currentPage - 1) * POSTS_PER_PAGE;
  const currentPosts = filteredPosts.slice(startIndex, startIndex + POSTS_PER_PAGE);

  // 当用户搜索时，重置到第一页
  const handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    setQuery(e.target.value);
    setCurrentPage(1);
  };

  return (
    <div>
      {/* 搜索框 */}
      <div className="mb-10 relative max-w-md mx-auto">
        <input
          type="text"
          placeholder="搜索文章..."
          value={query}
          onChange={handleSearch}
          className="w-full px-6 py-3 rounded-full border-2 border-anime-pink/30 focus:border-anime-pink focus:outline-none bg-white/50 dark:bg-gray-800/50 backdrop-blur-sm transition-all text-center placeholder-gray-400 dark:text-gray-100"
        />
        <span className="absolute right-4 top-3.5 text-anime-pink">🔍</span>
      </div>

      {/* 文章列表 (显示切分后的 currentPosts) */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
        {currentPosts.map((post) => (
          <article
            key={post.id}
            className="group bg-white dark:bg-gray-800 rounded-2xl p-6 shadow-lg shadow-anime-pink/20 dark:shadow-none hover:shadow-anime-pink/40 hover:-translate-y-1 transition-all duration-300 border border-gray-100 dark:border-gray-700 flex flex-col"
          >
            <div className="mb-4">
              <span className="text-xs font-medium text-anime-blue bg-anime-blue/10 dark:bg-anime-blue/20 px-2 py-1 rounded-full">
                {post.date}
              </span>
            </div>
            <h2 className="text-xl font-bold mb-2 group-hover:text-anime-pink transition-colors text-gray-800 dark:text-gray-100">
              {post.title}
            </h2>
            <p className="text-gray-500 dark:text-gray-400 text-sm line-clamp-3 mb-4 flex-grow">
              {post.description}
            </p>
            <Link
              href={`/posts/${post.id}`}
              className="text-sm font-medium text-anime-pink hover:text-anime-blue transition-colors mt-auto"
            >
              阅读更多 →
            </Link>
          </article>
        ))}
      </div>

      {/* 无结果提示 */}
      {filteredPosts.length === 0 && (
        <div className="text-center text-gray-500 py-10">
          没有找到相关文章 (｡•́︿•̀｡)
        </div>
      )}

      {/* 分页控制按钮 */}
      {filteredPosts.length > POSTS_PER_PAGE && (
        <div className="flex justify-center items-center gap-4 mt-12">
          <button
            onClick={() => setCurrentPage((p) => Math.max(1, p - 1))}
            disabled={currentPage === 1}
            className="px-4 py-2 rounded-lg bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 disabled:opacity-50 hover:bg-anime-pink hover:text-white transition-colors"
          >
            上一页
          </button>
          
          <span className="text-gray-600 dark:text-gray-300 font-medium">
            第 {currentPage} 页 / 共 {totalPages} 页
          </span>

          <button
            onClick={() => setCurrentPage((p) => Math.min(totalPages, p + 1))}
            disabled={currentPage === totalPages}
            className="px-4 py-2 rounded-lg bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 disabled:opacity-50 hover:bg-anime-pink hover:text-white transition-colors"
          >
            下一页
          </button>
        </div>
      )}
    </div>
  );
}
```

## 3. 试一试
保存文件后，去你的归档页面 (`/archive`) 看看。
如果你的文章超过了 6 篇，底部就会出现“上一页/下一页”的按钮。
如果你在搜索框里输入内容，分页也会自动根据搜索结果重新计算。

---
**现在的任务**：
1.  把上面的代码复制到 `src/components/SearchPosts.tsx`。
2.  去归档页面测试一下分页功能是否正常。
3.  **思考题**：如果我想每页显示 9 篇文章，应该改哪里？

做完告诉我，我们继续！



思考题:改const POSTS_PER_PAGE的值就行,显示9则改成9

---

# 第六章：部署问题修复 (Troubleshooting)

在将代码部署到 Vercel 时，我们可能会遇到一些构建错误。这里记录了最近遇到的一个问题及其解决方法。

## 1. 简历页面构建报错 (styled-jsx Error)

*   **报错信息**:
    ```
    Error: Turbopack build failed with 1 errors:
    ./src/app/resume
    Invalid import 'client-only' cannot be imported from a Server Component module.
    The error was caused by using 'styled-jsx'. It only works in a Client Component...
    ```
*   **原因**:
    我们在 `src/app/resume/page.tsx` 中使用了 `<style jsx>` 标签来处理打印样式。`styled-jsx` 是一个 CSS-in-JS 库，它需要在浏览器端运行（Client Side），但 Next.js 的页面默认是服务端组件（Server Component）。
*   **修复方法**:
    在 `src/app/resume/page.tsx` 文件的**最顶部**添加 `'use client';` 指令。
    ```tsx
    'use client'; // <--- 加上这一行

    import Link from 'next/link';
    // ...
    ```
*   **知识点**:
    只要你的组件里用到了 `<style jsx>`、`useState`、`useEffect` 或者浏览器特有的 API（比如 `window.print()`），就必须把它标记为 `'use client'`。

---

# 第七章：优化导航体验 (Clickable Logo)

你可能发现了一个小问题：在其他页面（比如归档页、文章页）时，点击左上角的 "AnimeBlog" 文字没有任何反应。按照习惯，点击 Logo 应该回到首页才对。

## 1. 修改思路
我们需要把原本只是普通文字的 `div` 标签，换成 Next.js 的 `Link` 组件，并指向首页 `/`。

**修改前**:
```tsx
<div className="text-xl font-bold text-anime-blue tracking-wider">
  AnimeBlog
</div>
```

**修改后**:
```tsx
<Link href="/" className="text-xl font-bold text-anime-blue tracking-wider hover:text-anime-pink transition-colors">
  AnimeBlog
</Link>
```

## 2. 涉及文件
因为我们的导航栏代码分散在各个页面里（这是我们之前提到的可以优化的地方），所以我们需要修改以下 5 个文件：
1.  `src/app/page.tsx` (首页)
2.  `src/app/archive/page.tsx` (归档页)
3.  `src/app/about/page.tsx` (关于页)
4.  `src/app/posts/[id]/page.tsx` (文章详情页)
5.  `src/app/resume/page.tsx` (简历页)

我已经帮你把这 5 个文件都修改好了！现在你可以去试试，无论在哪个页面，点击左上角的 "AnimeBlog" 都能瞬间回到首页。

## 3. 未来的优化方向 (Layout)
你肯定觉得改 5 个文件太麻烦了。
在 Next.js 中，我们可以把这个 Header 提取成一个单独的组件（比如 `src/components/Header.tsx`），然后在 `src/app/layout.tsx` 中引入它。
这样以后再改导航栏，就只需要改一个文件了。这可以作为你接下来的练习任务！
